"""
Sales Assistant CRM Beauty - Hauptanwendung
Ein vollst√§ndiges CRM-System f√ºr Friseursalons und Beauty-Studios
"""
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta, time
from database import init_database, execute_query, execute_update, get_connection
import sqlite3

# Seitenkonfiguration
st.set_page_config(
    page_title="Salon CRM Beauty",
    page_icon="üíá‚Äç‚ôÄÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Dark Mode Design
st.markdown("""
    <style>
    /* Hauptdesign - Dark Mode */
    .stApp {
        background: #0e1117;
        color: #fafafa;
    }
    
    .main-header {
        font-size: 2.5rem;
        font-weight: 600;
        color: #fafafa;
        text-align: center;
        margin-bottom: 2rem;
        padding: 1rem;
    }
    
    /* Sidebar Design - Dark */
    [data-testid="stSidebar"] {
        background: #1e1e1e;
        border-right: 1px solid #333333;
    }
    
    [data-testid="stSidebar"] .stSelectbox label,
    [data-testid="stSidebar"] .stMarkdown {
        color: #fafafa !important;
    }
    
    /* Metric Cards - Dark Mode */
    [data-testid="stMetricValue"] {
        font-size: 2rem !important;
        font-weight: 600 !important;
        color: #fafafa !important;
    }
    
    [data-testid="stMetricLabel"] {
        font-size: 0.9rem !important;
        color: #b0b0b0 !important;
    }
    
    /* Buttons - Dark Mode */
    .stButton > button {
        background: #262730;
        color: #fafafa;
        border: 1px solid #3a3a4a;
        border-radius: 6px;
        padding: 0.5rem 1.5rem;
        font-weight: 500;
        transition: all 0.2s ease;
    }
    
    .stButton > button:hover {
        background: #3a3a4a;
        border-color: #4a4a5a;
    }
    
    /* Primary Buttons */
    .stButton > button[kind="primary"] {
        background: #ff4b4b;
        border-color: #ff4b4b;
    }
    
    .stButton > button[kind="primary"]:hover {
        background: #ff6b6b;
        border-color: #ff6b6b;
    }
    
    /* Tabs - Dark Mode */
    .stTabs [data-baseweb="tab-list"] {
        gap: 4px;
        background-color: #1e1e1e;
        border-radius: 6px;
        padding: 4px;
    }
    
    .stTabs [data-baseweb="tab"] {
        border-radius: 4px;
        padding: 8px 16px;
        background-color: transparent;
        color: #b0b0b0;
        font-weight: 500;
    }
    
    .stTabs [aria-selected="true"] {
        background: #262730;
        color: #fafafa;
        border: 1px solid #3a3a4a;
    }
    
    /* Cards - Dark Mode */
    .card {
        background: #1e1e1e;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        margin-bottom: 1rem;
        border: 1px solid #333333;
    }
    
    
    /* Dataframes - Clean */
    .dataframe {
        border-radius: 6px;
        overflow: hidden;
        border: 1px solid #e0e0e0;
    }
    
    /* Success/Error Messages - Dezente Farben */
    .stSuccess {
        background: #d4edda;
        color: #155724;
        border-radius: 6px;
        padding: 1rem;
        border-left: 4px solid #28a745;
    }
    
    .stError {
        background: #f8d7da;
        color: #721c24;
        border-radius: 6px;
        padding: 1rem;
        border-left: 4px solid #dc3545;
    }
    
    .stInfo {
        background: #d1ecf1;
        color: #0c5460;
        border-radius: 6px;
        padding: 1rem;
        border-left: 4px solid #17a2b8;
    }
    
    .stWarning {
        background: #fff3cd;
        color: #856404;
        border-radius: 6px;
        padding: 1rem;
        border-left: 4px solid #ffc107;
    }
    
    /* Expander - Clean */
    .streamlit-expanderHeader {
        background: #f8f9fa;
        color: #2c3e50;
        border-radius: 6px;
        padding: 1rem;
        font-weight: 500;
        border: 1px solid #e0e0e0;
    }
    
    /* Radio Buttons */
    .stRadio > label {
        font-weight: 500;
        color: #2c3e50;
    }
    
    /* Hide Streamlit Menu */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
    
    /* Custom Scrollbar - Dezente Farben */
    ::-webkit-scrollbar {
        width: 8px;
    }
    
    ::-webkit-scrollbar-track {
        background: #f1f1f1;
    }
    
    ::-webkit-scrollbar-thumb {
        background: #bdc3c7;
        border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
        background: #95a5a6;
    }
    
    /* √úberschriften */
    h1, h2, h3 {
        color: #fafafa;
        font-weight: 600;
    }
    
    /* Text */
    p, span, div {
        color: #e0e0e0;
    }
    
    /* Main Content Background */
    .main .block-container {
        background: #0e1117;
        color: #fafafa;
    }
    
    /* Streamlit Elemente - Dark Mode */
    .stMarkdown {
        color: #fafafa;
    }
    
    .stText {
        color: #fafafa;
    }
    </style>
""", unsafe_allow_html=True)

# Initialisiere Datenbank
if 'db_initialized' not in st.session_state:
    init_database()
    st.session_state.db_initialized = True

# Dark Mode Sidebar Navigation
st.sidebar.markdown("""
    <div style='text-align: center; padding: 1.5rem 0; border-bottom: 1px solid #333333; margin-bottom: 1rem;'>
        <h1 style='color: #fafafa; font-size: 2rem; margin: 0;'>üíá‚Äç‚ôÄÔ∏è</h1>
        <h2 style='color: #fafafa; font-size: 1.3rem; margin: 0.5rem 0; font-weight: 600;'>Salon CRM</h2>
        <p style='color: #b0b0b0; font-size: 0.85rem; margin: 0;'>Beauty Management</p>
    </div>
""", unsafe_allow_html=True)

st.sidebar.markdown("---")

# Navigation mit Icons
nav_options = {
    "üìä Dashboard": "üìä",
    "üë• Kunden": "üë•",
    "üìÖ Termine": "üìÖ",
    "üí∞ Kasse": "üí∞",
    "üíÑ Produkte": "üíÑ",
    "üéÅ Marketing": "üéÅ",
    "üìà Analytics": "üìà",
    "üí¨ Frontend Chat": "üí¨"
}

page = st.sidebar.radio(
    "Navigation",
    list(nav_options.keys()),
    label_visibility="collapsed"
)

st.sidebar.markdown("---")
st.sidebar.markdown("""
    <div style='text-align: center; padding: 1rem 0; color: #808080; font-size: 0.75rem; border-top: 1px solid #333333; margin-top: 1rem;'>
        <p style='margin: 0.25rem 0;'>Version 2.0</p>
        <p style='margin: 0.25rem 0;'>¬© 2025 Salon CRM</p>
    </div>
""", unsafe_allow_html=True)

# Hilfsfunktionen
def get_today_stats():
    """Holt Statistiken f√ºr heute"""
    today = datetime.now().strftime("%Y-%m-%d")
    
    # Heutige Termine
    appointments = execute_query("""
        SELECT COUNT(*) as count FROM appointments 
        WHERE appointment_date = ? AND status != 'abgesagt'
    """, (today,))
    
    # Heutige Verk√§ufe
    sales = execute_query("""
        SELECT COUNT(*) as count, COALESCE(SUM(total_amount - discount), 0) as total 
        FROM sales WHERE sale_date = ?
    """, (today,))
    
    # Offene Termine heute
    open_appointments = execute_query("""
        SELECT COUNT(*) as count FROM appointments 
        WHERE appointment_date = ? AND status = 'geplant'
    """, (today,))
    
    return {
        'appointments': appointments[0]['count'] if appointments else 0,
        'sales_count': sales[0]['count'] if sales else 0,
        'sales_total': sales[0]['total'] if sales else 0,
        'open_appointments': open_appointments[0]['count'] if open_appointments else 0
    }

def get_customers():
    """Holt alle Kunden"""
    return execute_query("SELECT * FROM customers ORDER BY last_name, first_name")

def get_services():
    """Holt alle aktiven Dienstleistungen"""
    return execute_query("SELECT * FROM services WHERE active = 1 ORDER BY category, name")

def get_products():
    """Holt alle Produkte"""
    return execute_query("SELECT * FROM products ORDER BY category, name")

def get_appointments(date=None):
    """Holt Termine f√ºr ein bestimmtes Datum"""
    if date:
        return execute_query("""
            SELECT a.*, c.first_name || ' ' || c.last_name as customer_name, s.name as service_name,
                   e.first_name || ' ' || e.last_name as employee_name, e.id as employee_id
            FROM appointments a
            LEFT JOIN customers c ON a.customer_id = c.id
            LEFT JOIN services s ON a.service_id = s.id
            LEFT JOIN employees e ON a.employee_id = e.id
            WHERE a.appointment_date = ?
            ORDER BY a.appointment_time
        """, (date,))
    else:
        return execute_query("""
            SELECT a.*, c.first_name || ' ' || c.last_name as customer_name, s.name as service_name,
                   e.first_name || ' ' || e.last_name as employee_name, e.id as employee_id
            FROM appointments a
            LEFT JOIN customers c ON a.customer_id = c.id
            LEFT JOIN services s ON a.service_id = s.id
            LEFT JOIN employees e ON a.employee_id = e.id
            ORDER BY a.appointment_date DESC, a.appointment_time DESC
            LIMIT 50
        """)

# DASHBOARD
if page == "üìä Dashboard":
    st.markdown("""
        <div style='text-align: center; padding: 2rem 0;'>
            <h1 class="main-header">üíá‚Äç‚ôÄÔ∏è Salon CRM Beauty</h1>
            <p style='font-size: 1.1rem; color: #7f8c8d; margin-top: -1rem;'>Willkommen zur√ºck! Hier ist Ihre √úbersicht.</p>
        </div>
    """, unsafe_allow_html=True)
    
    stats = get_today_stats()
    
    # Moderne Metriken mit Cards
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
            <div class="card" style='background: #ffffff; text-align: center; padding: 1.5rem; border-left: 4px solid #2c3e50;'>
                <div style='font-size: 2rem; margin-bottom: 0.5rem; color: #2c3e50;'>üìÖ</div>
                <div style='font-size: 2rem; font-weight: 600; color: #2c3e50;'>{stats['appointments']}</div>
                <div style='font-size: 0.85rem; color: #7f8c8d; margin-top: 0.5rem;'>Heutige Termine</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
            <div class="card" style='background: #ffffff; text-align: center; padding: 1.5rem; border-left: 4px solid #2c3e50;'>
                <div style='font-size: 2rem; margin-bottom: 0.5rem; color: #2c3e50;'>‚úÖ</div>
                <div style='font-size: 2rem; font-weight: 600; color: #2c3e50;'>{stats['open_appointments']}</div>
                <div style='font-size: 0.85rem; color: #7f8c8d; margin-top: 0.5rem;'>Offene Termine</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
            <div class="card" style='background: #ffffff; text-align: center; padding: 1.5rem; border-left: 4px solid #2c3e50;'>
                <div style='font-size: 2rem; margin-bottom: 0.5rem; color: #2c3e50;'>üí∞</div>
                <div style='font-size: 2rem; font-weight: 600; color: #2c3e50;'>{stats['sales_count']}</div>
                <div style='font-size: 0.85rem; color: #7f8c8d; margin-top: 0.5rem;'>Verk√§ufe heute</div>
            </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
            <div class="card" style='background: #ffffff; text-align: center; padding: 1.5rem; border-left: 4px solid #2c3e50;'>
                <div style='font-size: 2rem; margin-bottom: 0.5rem; color: #2c3e50;'>üíµ</div>
                <div style='font-size: 2rem; font-weight: 600; color: #2c3e50;'>‚Ç¨{stats['sales_total']:.2f}</div>
                <div style='font-size: 0.85rem; color: #7f8c8d; margin-top: 0.5rem;'>Umsatz heute</div>
            </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # Charts mit modernem Design
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìà Umsatz der letzten 7 Tage")
        sales_data = execute_query("""
            SELECT sale_date, SUM(total_amount - discount) as total
            FROM sales
            WHERE sale_date >= date('now', '-7 days')
            GROUP BY sale_date
            ORDER BY sale_date
        """)
        
        if sales_data:
            df_sales = pd.DataFrame(sales_data)
            fig = px.line(df_sales, x='sale_date', y='total', 
                         labels={'sale_date': 'Datum', 'total': 'Umsatz (‚Ç¨)'},
                         color_discrete_sequence=['#2c3e50'])
            fig.update_layout(
                plot_bgcolor='#ffffff',
                paper_bgcolor='#ffffff',
                font=dict(size=12, color='#2c3e50'),
                height=400
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Noch keine Verkaufsdaten vorhanden")
    
    with col2:
        st.subheader("üìä Top Dienstleistungen")
        top_services = execute_query("""
            SELECT s.name, COUNT(si.id) as count, SUM(si.price) as revenue
            FROM sale_items si
            JOIN services s ON si.item_id = s.id
            WHERE si.item_type = 'service'
            AND si.sale_id IN (SELECT id FROM sales WHERE sale_date >= date('now', '-30 days'))
            GROUP BY s.id, s.name
            ORDER BY count DESC
            LIMIT 5
        """)
        
        if top_services:
            df_services = pd.DataFrame(top_services)
            fig = px.bar(df_services, x='name', y='count', 
                        labels={'name': 'Dienstleistung', 'count': 'Anzahl'},
                        color='count',
                        color_continuous_scale='Greys')
            fig.update_layout(
                plot_bgcolor='#ffffff',
                paper_bgcolor='#ffffff',
                font=dict(size=12, color='#2c3e50'),
                height=400
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Noch keine Daten vorhanden")
    
    # Heutige Termine
    st.subheader("üìÖ Heutige Termine")
    today = datetime.now().strftime("%Y-%m-%d")
    today_appointments = get_appointments(today)
    
    if today_appointments:
        df_appointments = pd.DataFrame(today_appointments)
        st.dataframe(df_appointments[['appointment_time', 'customer_name', 'service_name', 'employee_name', 'status']], 
                    use_container_width=True, hide_index=True)
    else:
        st.info("Keine Termine f√ºr heute geplant")

# KUNDEN
elif page == "üë• Kunden":
    st.markdown("""
        <div style='text-align: center; padding: 1rem 0; margin-bottom: 2rem;'>
            <h1 style='font-size: 2.5rem; font-weight: 600; color: #2c3e50;'>üë• Kundenverwaltung</h1>
        </div>
    """, unsafe_allow_html=True)
    
    tab1, tab2, tab3 = st.tabs(["Kundenliste", "Neuer Kunde", "Treueprogramm"])
    
    with tab1:
        customers = get_customers()
        if customers:
            df = pd.DataFrame(customers)
            st.dataframe(df[['first_name', 'last_name', 'email', 'phone', 'loyalty_points']], 
                        use_container_width=True, hide_index=True)
            
            # Kunden bearbeiten
            st.subheader("Kunde bearbeiten")
            customer_options = {f"{c['first_name']} {c['last_name']}": c['id'] for c in customers}
            selected_customer = st.selectbox("Kunde ausw√§hlen", list(customer_options.keys()))
            
            if selected_customer:
                customer_id = customer_options[selected_customer]
                customer = [c for c in customers if c['id'] == customer_id][0]
                
                col1, col2 = st.columns(2)
                with col1:
                    new_first_name = st.text_input("Vorname", value=customer['first_name'])
                    new_email = st.text_input("E-Mail", value=customer['email'] or "")
                    new_address = st.text_area("Adresse", value=customer['address'] or "")
                
                with col2:
                    new_last_name = st.text_input("Nachname", value=customer['last_name'])
                    new_phone = st.text_input("Telefon", value=customer['phone'] or "")
                    new_notes = st.text_area("Notizen", value=customer['notes'] or "")
                
                if st.button("Kunde aktualisieren"):
                    execute_update("""
                        UPDATE customers 
                        SET first_name = ?, last_name = ?, email = ?, phone = ?, 
                            address = ?, notes = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE id = ?
                    """, (new_first_name, new_last_name, new_email, new_phone, 
                          new_address, new_notes, customer_id))
                    st.success("Kunde aktualisiert!")
                    st.rerun()
        else:
            st.info("Noch keine Kunden vorhanden")
    
    with tab2:
        st.subheader("Neuen Kunden anlegen")
        col1, col2 = st.columns(2)
        
        with col1:
            first_name = st.text_input("Vorname *")
            email = st.text_input("E-Mail")
            address = st.text_area("Adresse")
            birthdate = st.date_input("Geburtsdatum", value=None)
        
        with col2:
            last_name = st.text_input("Nachname *")
            phone = st.text_input("Telefon")
            notes = st.text_area("Notizen")
        
        if st.button("Kunde speichern"):
            if first_name and last_name:
                execute_update("""
                    INSERT INTO customers (first_name, last_name, email, phone, address, birthdate, notes)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (first_name, last_name, email or None, phone or None, 
                      address or None, str(birthdate) if birthdate else None, notes or None))
                st.success("Kunde erfolgreich angelegt!")
                st.rerun()
            else:
                st.error("Vorname und Nachname sind Pflichtfelder!")
    
    with tab3:
        st.subheader("Treueprogramm")
        customers = get_customers()
        if customers:
            df_loyalty = pd.DataFrame(customers)
            df_loyalty = df_loyalty[df_loyalty['loyalty_points'] > 0].sort_values('loyalty_points', ascending=False)
            
            if not df_loyalty.empty:
                st.dataframe(df_loyalty[['first_name', 'last_name', 'loyalty_points']], 
                           use_container_width=True, hide_index=True)
            else:
                st.info("Noch keine Treuepunkte vergeben")

# TERMINE (SimplyBook.me Style)
elif page == "üìÖ Termine":
    st.markdown("""
        <div style='text-align: center; padding: 1rem 0; margin-bottom: 2rem;'>
            <h1 style='font-size: 2.5rem; font-weight: 600; color: #2c3e50;'>üìÖ Terminbuchung</h1>
            <p style='color: #7f8c8d; font-size: 1rem;'>Professionelle Terminverwaltung</p>
        </div>
    """, unsafe_allow_html=True)
    
    from booking_system import (
        get_available_time_slots, check_availability, 
        get_weekly_calendar, get_employee_schedule, 
        create_online_booking, get_upcoming_appointments
    )
    
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üìÖ Kalender", "‚ûï Neue Buchung", "üåê Online-Buchung", "üìã √úbersicht", "‚≠ê Bewertungen"])
    
    with tab1:
        st.subheader("üìÖ Kalenderansicht")
        
        view_mode = st.radio("Ansicht", ["Tag", "Woche", "Monat"], horizontal=True)
        
        if view_mode == "Tag":
            selected_date = st.date_input("Datum ausw√§hlen", value=datetime.now())
            appointments = get_appointments(str(selected_date))
            
            if appointments:
                # Zeige Termine nach Mitarbeiter gruppiert
                employees = execute_query("SELECT * FROM employees WHERE active = 1")
                
                if employees:
                    cols = st.columns(len(employees) + 1)
                    with cols[0]:
                        st.write("**Zeit**")
                    
                    for idx, emp in enumerate(employees):
                        with cols[idx + 1]:
                            st.write(f"**{emp['first_name']} {emp['last_name']}**")
                    
                    # Zeitbl√∂cke (9:00 - 18:00, alle 30 Min)
                    time_slots = []
                    current = datetime.combine(selected_date, time(9, 0))
                    end = datetime.combine(selected_date, time(18, 0))
                    while current < end:
                        time_slots.append(current.time())
                        current += timedelta(minutes=30)
                    
                    for slot in time_slots:
                        cols = st.columns(len(employees) + 1)
                        with cols[0]:
                            st.write(slot.strftime("%H:%M"))
                        
                        for idx, emp in enumerate(employees):
                            with cols[idx + 1]:
                                # Finde Termine f√ºr diesen Mitarbeiter und Zeit
                                emp_appointments = []
                                slot_time_str = slot.strftime("%H:%M")
                                
                                for a in appointments:
                                    apt_time = a.get('appointment_time', '')
                                    if apt_time:
                                        # Normalisiere Zeitformat (kann HH:MM oder HH:MM:SS sein)
                                        apt_time_parts = apt_time.split(':')
                                        if len(apt_time_parts) >= 2:
                                            apt_time_normalized = f"{apt_time_parts[0]}:{apt_time_parts[1]}"
                                            
                                            # Pr√ºfe Mitarbeiter-Zuordnung
                                            apt_emp_id = a.get('employee_id')
                                            matches_employee = (apt_emp_id == emp['id']) if apt_emp_id else False
                                            
                                            # Pr√ºfe Zeit√ºbereinstimmung
                                            if matches_employee and apt_time_normalized == slot_time_str:
                                                emp_appointments.append(a)
                                
                                if emp_appointments:
                                    apt = emp_appointments[0]
                                    customer_name = apt.get('customer_name', 'Unbekannt')
                                    service_name = apt.get('service_name', 'Unbekannt')
                                    st.info(f"üìå {customer_name}\n{service_name}")
                else:
                    # Fallback: Einfache Liste
                    df = pd.DataFrame(appointments)
                    st.dataframe(df[['appointment_time', 'customer_name', 'service_name', 
                                   'employee_name', 'status']], use_container_width=True, hide_index=True)
            else:
                st.info(f"Keine Termine f√ºr {selected_date.strftime('%d.%m.%Y')}")
        
        elif view_mode == "Woche":
            week_start = st.date_input("Woche beginnen", value=datetime.now() - timedelta(days=datetime.now().weekday()))
            calendar_df = get_weekly_calendar(str(week_start))
            
            if not calendar_df.empty:
                st.dataframe(calendar_df, use_container_width=True, hide_index=True)
            else:
                st.info("Keine Termine in dieser Woche")
        
        elif view_mode == "Monat":
            month = st.date_input("Monat", value=datetime.now().replace(day=1))
            # Zeige Kalender-Grid f√ºr den Monat
            st.info("Monatsansicht - In Entwicklung")
    
    with tab2:
        st.subheader("‚ûï Neuen Termin buchen")
        
        customers = get_customers()
        services = get_services()
        employees = execute_query("SELECT * FROM employees WHERE active = 1")
        
        if services:
            # Service ausw√§hlen
            service_options = {f"{s['name']} (‚Ç¨{s['price']:.2f}, {s['duration']} Min)": s for s in services}
            selected_service_name = st.selectbox("Dienstleistung *", list(service_options.keys()))
            selected_service = service_options[selected_service_name]
            
            # Datum ausw√§hlen
            appointment_date = st.date_input("Datum *", value=datetime.now(), min_value=datetime.now().date())
            date_str = str(appointment_date)
            
            # Mitarbeiter ausw√§hlen (optional)
            employee_id = None
            if employees:
                emp_options = {f"{e['first_name']} {e['last_name']}": e['id'] for e in employees}
                emp_options["Keine Pr√§ferenz"] = None
                selected_emp_name = st.selectbox("Mitarbeiter (optional)", list(emp_options.keys()))
                employee_id = emp_options[selected_emp_name]
            
            # Verf√ºgbare Zeiten anzeigen
            available_slots = get_available_time_slots(date_str, employee_id, selected_service['duration'] or 60)
            
            if available_slots:
                st.success(f"‚úÖ {len(available_slots)} verf√ºgbare Zeitfenster gefunden")
                
                # Zeit ausw√§hlen
                cols = st.columns(4)
                selected_time = None
                for idx, slot in enumerate(available_slots[:12]):  # Zeige max 12 Slots
                    with cols[idx % 4]:
                        if st.button(slot, key=f"slot_{idx}"):
                            selected_time = slot
                            st.session_state.selected_time = slot
                
                if 'selected_time' in st.session_state:
                    selected_time = st.session_state.selected_time
                    st.info(f"üïê Ausgew√§hlte Zeit: {selected_time}")
                
                # Wiederkehrende Buchung?
                is_recurring = st.checkbox("üîÑ Wiederkehrende Buchung")
                
                recurring_pattern = None
                recurring_count = 1
                if is_recurring:
                    col_rec1, col_rec2 = st.columns(2)
                    with col_rec1:
                        recurring_pattern = st.selectbox("Wiederholung", 
                                                         ["T√§glich", "W√∂chentlich", "Monatlich"],
                                                         key="recurring_pattern")
                    with col_rec2:
                        recurring_count = st.number_input("Anzahl Termine", min_value=2, max_value=52, value=4)
                
                # Gruppenbuchung?
                is_group = st.checkbox("üë• Gruppenbuchung")
                group_size = 1
                if is_group:
                    group_size = st.number_input("Anzahl Personen", min_value=2, max_value=10, value=2)
                
                # Kunde ausw√§hlen oder neu anlegen
                customer_choice = st.radio("Kunde", ["Bestehender Kunde", "Neuer Kunde"])
                
                customer_id = None
                if customer_choice == "Bestehender Kunde" and customers:
                    customer_options = {f"{c['first_name']} {c['last_name']}": c['id'] for c in customers}
                    selected_customer = st.selectbox("Kunde ausw√§hlen", list(customer_options.keys()))
                    customer_id = customer_options[selected_customer]
                else:
                    col1, col2 = st.columns(2)
                    with col1:
                        new_first_name = st.text_input("Vorname *")
                        new_last_name = st.text_input("Nachname *")
                    with col2:
                        new_email = st.text_input("E-Mail")
                        new_phone = st.text_input("Telefon")
                
                notes = st.text_area("Notizen (optional)")
                
                if st.button("‚úÖ Termin buchen", type="primary"):
                    if not selected_time:
                        st.error("Bitte eine Zeit ausw√§hlen!")
                    elif customer_choice == "Bestehender Kunde" and not customer_id:
                        st.error("Bitte einen Kunden ausw√§hlen!")
                    elif customer_choice == "Neuer Kunde" and (not new_first_name or not new_last_name):
                        st.error("Vorname und Nachname sind Pflichtfelder!")
                    else:
                        try:
                            if customer_choice == "Neuer Kunde":
                                customer_id = execute_update("""
                                    INSERT INTO customers (first_name, last_name, email, phone)
                                    VALUES (?, ?, ?, ?)
                                """, (new_first_name, new_last_name, new_email or None, new_phone or None))
                            
                            # Pr√ºfe Verf√ºgbarkeit nochmal
                            is_available, message = check_availability(
                                date_str, selected_time, employee_id, selected_service['duration'] or 60
                            )
                            
                            if is_available:
                                from simplybook_features import create_recurring_appointments, create_group_booking
                                
                                if is_recurring:
                                    # Wiederkehrende Buchung
                                    pattern_map = {"T√§glich": "daily", "W√∂chentlich": "weekly", "Monatlich": "monthly"}
                                    pattern = pattern_map[recurring_pattern]
                                    apt_ids = create_recurring_appointments(
                                        customer_id, selected_service['id'], date_str, 
                                        selected_time, employee_id, pattern, recurring_count
                                    )
                                    st.success(f"‚úÖ {len(apt_ids)} wiederkehrende Termine erfolgreich gebucht!")
                                elif is_group:
                                    # Gruppenbuchung
                                    apt_id = create_group_booking(
                                        [customer_id], selected_service['id'], 
                                        date_str, selected_time, employee_id
                                    )
                                    execute_update("UPDATE appointments SET group_size = ? WHERE id = ?", 
                                                 (group_size, apt_id))
                                    st.success(f"‚úÖ Gruppenbuchung f√ºr {group_size} Personen erfolgreich gebucht!")
                                else:
                                    # Einzelbuchung
                                    execute_update("""
                                        INSERT INTO appointments (customer_id, service_id, employee_id, 
                                                                appointment_date, appointment_time, duration, notes, status, group_size)
                                        VALUES (?, ?, ?, ?, ?, ?, ?, 'geplant', ?)
                                    """, (customer_id, selected_service['id'], employee_id, 
                                          date_str, selected_time, selected_service['duration'], notes or None, group_size))
                                    st.success(f"‚úÖ Termin erfolgreich gebucht f√ºr {selected_time}!")
                                
                                if 'selected_time' in st.session_state:
                                    del st.session_state.selected_time
                                st.rerun()
                            else:
                                st.error(f"‚ùå {message}")
                        except Exception as e:
                            st.error(f"Fehler: {str(e)}")
            else:
                st.warning("‚ö†Ô∏è Keine verf√ºgbaren Zeitfenster f√ºr dieses Datum")
        else:
            st.warning("Bitte zuerst Dienstleistungen anlegen!")
    
    with tab3:
        st.subheader("üåê Online-Buchungsformular")
        st.info("Dieses Formular kann von Kunden verwendet werden, um selbst Termine zu buchen.")
        
        services = get_services()
        employees = execute_query("SELECT * FROM employees WHERE active = 1")
        
        if services:
            # Service ausw√§hlen
            service_options = {f"{s['name']} - ‚Ç¨{s['price']:.2f} ({s['duration']} Min)": s for s in services}
            selected_service_name = st.selectbox("Dienstleistung w√§hlen *", list(service_options.keys()))
            selected_service = service_options[selected_service_name]
            
            # Kundendaten
            st.subheader("Ihre Daten")
            col1, col2 = st.columns(2)
            with col1:
                first_name = st.text_input("Vorname *")
                email = st.text_input("E-Mail *")
            with col2:
                last_name = st.text_input("Nachname *")
                phone = st.text_input("Telefon")
            
            # Termin ausw√§hlen
            st.subheader("Termin ausw√§hlen")
            appointment_date = st.date_input("Datum *", value=datetime.now(), min_value=datetime.now().date())
            date_str = str(appointment_date)
            
            # Verf√ºgbare Zeiten
            available_slots = get_available_time_slots(date_str, None, selected_service['duration'] or 60)
            
            if available_slots:
                selected_time = st.selectbox("Uhrzeit *", available_slots)
                
                if st.button("üìÖ Termin jetzt buchen", type="primary"):
                    if first_name and last_name and email:
                        try:
                            customer_data = {
                                'first_name': first_name,
                                'last_name': last_name,
                                'email': email,
                                'phone': phone
                            }
                            appointment_id = create_online_booking(
                                customer_data, selected_service['id'], date_str, selected_time
                            )
                            st.success(f"""
                            ‚úÖ **Termin erfolgreich gebucht!**
                            
                            - **Datum:** {appointment_date.strftime('%d.%m.%Y')}
                            - **Uhrzeit:** {selected_time}
                            - **Service:** {selected_service['name']}
                            - **Buchungsnummer:** #{appointment_id}
                            
                            Sie erhalten eine Best√§tigung per E-Mail.
                            """)
                            st.balloons()
                        except Exception as e:
                            st.error(f"‚ùå {str(e)}")
                    else:
                        st.error("Bitte f√ºllen Sie alle Pflichtfelder aus!")
            else:
                st.warning("‚ö†Ô∏è Keine verf√ºgbaren Termine f√ºr dieses Datum. Bitte w√§hlen Sie ein anderes Datum.")
        else:
            st.warning("Keine Dienstleistungen verf√ºgbar.")
    
    with tab4:
        st.subheader("üìã Kommende Termine")
        
        days_ahead = st.slider("Zeitraum (Tage)", 1, 30, 7)
        upcoming = get_upcoming_appointments(days_ahead)
        
        if upcoming:
            df = pd.DataFrame(upcoming)
            st.dataframe(df[['appointment_date', 'appointment_time', 'customer_name', 
                           'service_name', 'employee_name', 'status']], 
                        use_container_width=True, hide_index=True)
            
            # Termine verwalten
            st.subheader("Termin bearbeiten")
            apt_options = {f"{a['appointment_date']} {a['appointment_time']} - {a['customer_name']}": a['id'] 
                          for a in upcoming}
            selected_apt = st.selectbox("Termin ausw√§hlen", list(apt_options.keys()))
            
            if selected_apt:
                apt_id = apt_options[selected_apt]
                apt = [a for a in upcoming if a['id'] == apt_id][0]
                
                col1, col2 = st.columns(2)
                with col1:
                    new_status = st.selectbox("Status", 
                                             ["geplant", "best√§tigt", "abgeschlossen", "abgesagt"],
                                             index=["geplant", "best√§tigt", "abgeschlossen", "abgesagt"].index(apt['status']),
                                             key=f"status_{apt_id}")
                with col2:
                    if st.button("Status aktualisieren", key=f"update_{apt_id}"):
                        execute_update("UPDATE appointments SET status = ? WHERE id = ?", 
                                     (new_status, apt_id))
                        st.success("Status aktualisiert!")
                        st.rerun()
        else:
            st.info("Keine kommenden Termine")
        
        # Erinnerungen senden
        st.divider()
        st.subheader("üìß Erinnerungen")
        from simplybook_features import get_appointments_needing_reminder, send_appointment_reminder
        
        reminders_needed = get_appointments_needing_reminder(24)
        if reminders_needed:
            st.info(f"üì¨ {len(reminders_needed)} Termine ben√∂tigen Erinnerungen (24h vorher)")
            if st.button("üìß Erinnerungen jetzt senden"):
                sent = 0
                for apt in reminders_needed:
                    if send_appointment_reminder(apt['id']):
                        sent += 1
                st.success(f"‚úÖ {sent} Erinnerungen gesendet!")
                st.rerun()
        else:
            st.success("‚úÖ Alle Erinnerungen sind aktuell")
    
    with tab5:
        st.subheader("‚≠ê Bewertungen & Feedback")
        
        from simplybook_features import get_service_reviews, get_average_rating, add_review
        
        # Abgeschlossene Termine f√ºr Bewertung
        completed_appointments = execute_query("""
            SELECT a.*, c.first_name || ' ' || c.last_name as customer_name, 
                   s.name as service_name, s.id as service_id
            FROM appointments a
            JOIN customers c ON a.customer_id = c.id
            JOIN services s ON a.service_id = s.id
            WHERE a.status = 'abgeschlossen'
            AND a.id NOT IN (SELECT appointment_id FROM reviews)
            ORDER BY a.appointment_date DESC
            LIMIT 20
        """)
        
        if completed_appointments:
            st.write("**Termine zur Bewertung:**")
            for apt in completed_appointments:
                with st.expander(f"{apt['appointment_date']} - {apt['customer_name']} - {apt['service_name']}"):
                    rating = st.slider("Bewertung", 1, 5, 5, key=f"rating_{apt['id']}")
                    comment = st.text_area("Kommentar (optional)", key=f"comment_{apt['id']}")
                    if st.button("Bewertung abgeben", key=f"submit_{apt['id']}"):
                        add_review(apt['id'], apt['customer_id'], rating, comment)
                        st.success("‚úÖ Bewertung gespeichert!")
                        st.rerun()
        else:
            st.info("Keine Termine zur Bewertung verf√ºgbar")
        
        st.divider()
        st.subheader("üìä Bewertungs√ºbersicht")
        
        services = get_services()
        if services:
            service_options = {f"{s['name']}": s['id'] for s in services}
            selected_service_name = st.selectbox("Service ausw√§hlen", list(service_options.keys()))
            service_id = service_options[selected_service_name]
            
            avg_rating = get_average_rating(service_id)
            reviews = get_service_reviews(service_id)
            
            if reviews:
                st.metric("Durchschnittliche Bewertung", f"{avg_rating} ‚≠ê ({len(reviews)} Bewertungen)")
                
                for review in reviews:
                    st.write(f"**{review['customer_name']}** - {review['rating']} ‚≠ê")
                    if review['comment']:
                        st.write(review['comment'])
                    st.write(f"*{review['appointment_date']}*")
                    st.divider()
            else:
                st.info("Noch keine Bewertungen f√ºr diesen Service")

# KASSE
elif page == "üí∞ Kasse":
    st.markdown("""
        <div style='text-align: center; padding: 1rem 0; margin-bottom: 2rem;'>
            <h1 style='font-size: 2.5rem; font-weight: 600; color: #2c3e50;'>üí∞ Kassensystem</h1>
        </div>
    """, unsafe_allow_html=True)
    
    customers = get_customers()
    services = get_services()
    products = get_products()
    
    if customers and (services or products):
        selected_customer = st.selectbox("Kunde", ["Kein Kunde"] + [f"{c['first_name']} {c['last_name']}" for c in customers])
        customer_id = None
        if selected_customer != "Kein Kunde":
            customer_id = [c['id'] for c in customers if f"{c['first_name']} {c['last_name']}" == selected_customer][0]
        
        st.subheader("Warenkorb")
        if 'cart' not in st.session_state:
            st.session_state.cart = []
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            item_type = st.radio("Art", ["Dienstleistung", "Produkt"])
            
            if item_type == "Dienstleistung" and services:
                service_options = {f"{s['name']} - ‚Ç¨{s['price']:.2f}": s for s in services}
                selected_service = st.selectbox("Dienstleistung ausw√§hlen", list(service_options.keys()))
                if st.button("Hinzuf√ºgen"):
                    service = service_options[selected_service]
                    st.session_state.cart.append({
                        'type': 'service',
                        'id': service['id'],
                        'name': service['name'],
                        'price': service['price'],
                        'quantity': 1
                    })
                    st.rerun()
            
            elif item_type == "Produkt" and products:
                product_options = {f"{p['name']} - ‚Ç¨{p['price']:.2f} (Lager: {p['stock_quantity']})": p for p in products}
                selected_product = st.selectbox("Produkt ausw√§hlen", list(product_options.keys()))
                quantity = st.number_input("Menge", min_value=1, value=1)
                if st.button("Hinzuf√ºgen"):
                    product = product_options[selected_product]
                    if product['stock_quantity'] >= quantity:
                        st.session_state.cart.append({
                            'type': 'product',
                            'id': product['id'],
                            'name': product['name'],
                            'price': product['price'],
                            'quantity': quantity
                        })
                        st.rerun()
                    else:
                        st.error("Nicht genug Lagerbestand!")
        
        with col2:
            if st.session_state.cart:
                st.write("**Warenkorb:**")
                total = 0
                for item in st.session_state.cart:
                    item_total = item['price'] * item['quantity']
                    total += item_total
                    st.write(f"- {item['name']} x{item['quantity']}: ‚Ç¨{item_total:.2f}")
                
                discount = st.number_input("Rabatt (‚Ç¨)", min_value=0.0, value=0.0, step=0.5)
                final_total = total - discount
                
                st.metric("Gesamt", f"‚Ç¨{final_total:.2f}")
                
                payment_method = st.selectbox("Zahlungsart", ["Bar", "Karte", "√úberweisung"])
                
                if st.button("üí≥ Verkauf abschlie√üen", type="primary"):
                    now = datetime.now()
                    sale_id = execute_update("""
                        INSERT INTO sales (customer_id, sale_date, sale_time, total_amount, 
                                         payment_method, discount)
                        VALUES (?, ?, ?, ?, ?, ?)
                    """, (customer_id, now.strftime("%Y-%m-%d"), now.strftime("%H:%M:%S"), 
                          total, payment_method, discount))
                    
                    # Verkaufsdetails speichern
                    for item in st.session_state.cart:
                        execute_update("""
                            INSERT INTO sale_items (sale_id, item_type, item_id, item_name, quantity, price)
                            VALUES (?, ?, ?, ?, ?, ?)
                        """, (sale_id, item['type'], item['id'], item['name'], item['quantity'], item['price']))
                        
                        # Lagerbestand reduzieren bei Produkten
                        if item['type'] == 'product':
                            execute_update("""
                                UPDATE products 
                                SET stock_quantity = stock_quantity - ?
                                WHERE id = ?
                            """, (item['quantity'], item['id']))
                    
                    # Treuepunkte vergeben (1 Punkt pro 10‚Ç¨)
                    if customer_id:
                        points_earned = int(final_total / 10)
                        if points_earned > 0:
                            execute_update("""
                                UPDATE customers 
                                SET loyalty_points = loyalty_points + ?
                                WHERE id = ?
                            """, (points_earned, customer_id))
                    
                    st.session_state.cart = []
                    st.success(f"Verkauf erfolgreich! Verkaufs-ID: {sale_id}")
                    st.rerun()
            else:
                st.info("Warenkorb ist leer")
    else:
        st.warning("Bitte zuerst Kunden, Dienstleistungen und Produkte anlegen!")

# PRODUKTE
elif page == "üíÑ Produkte":
    st.markdown("""
        <div style='text-align: center; padding: 1rem 0; margin-bottom: 2rem;'>
            <h1 style='font-size: 2.5rem; font-weight: 600; color: #2c3e50;'>üíÑ Produktverwaltung</h1>
        </div>
    """, unsafe_allow_html=True)
    
    tab1, tab2, tab3 = st.tabs(["Produktliste", "Neues Produkt", "Lagerbestand"])
    
    with tab1:
        products = get_products()
        if products:
            df = pd.DataFrame(products)
            st.dataframe(df[['name', 'category', 'brand', 'price', 'stock_quantity', 'min_stock_level']], 
                        use_container_width=True, hide_index=True)
        else:
            st.info("Noch keine Produkte vorhanden")
    
    with tab2:
        st.subheader("Neues Produkt anlegen")
        col1, col2 = st.columns(2)
        
        with col1:
            name = st.text_input("Produktname *")
            category = st.selectbox("Kategorie", ["Pflege", "Styling", "F√§rben", "Werkzeuge", "Sonstiges"])
            brand = st.text_input("Marke")
        
        with col2:
            price = st.number_input("Preis (‚Ç¨) *", min_value=0.0, step=0.1)
            stock_quantity = st.number_input("Lagerbestand", min_value=0, value=0)
            min_stock_level = st.number_input("Mindestbestand", min_value=0, value=5)
        
        description = st.text_area("Beschreibung")
        
        if st.button("Produkt speichern"):
            if name and price >= 0:
                execute_update("""
                    INSERT INTO products (name, category, brand, price, stock_quantity, min_stock_level, description)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (name, category, brand or None, price, stock_quantity, min_stock_level, description or None))
                st.success("Produkt erfolgreich angelegt!")
                st.rerun()
            else:
                st.error("Produktname und Preis sind Pflichtfelder!")
    
    with tab3:
        st.subheader("Lagerbestand verwalten")
        products = get_products()
        low_stock = [p for p in products if p['stock_quantity'] <= p['min_stock_level']]
        
        if low_stock:
            st.warning(f"‚ö†Ô∏è {len(low_stock)} Produkte haben niedrigen Bestand!")
            df_low = pd.DataFrame(low_stock)
            st.dataframe(df_low[['name', 'stock_quantity', 'min_stock_level']], 
                        use_container_width=True, hide_index=True)
        
        if products:
            product_options = {p['name']: p['id'] for p in products}
            selected_product = st.selectbox("Produkt ausw√§hlen", list(product_options.keys()))
            new_quantity = st.number_input("Neuer Lagerbestand", min_value=0, value=0)
            
            if st.button("Bestand aktualisieren"):
                execute_update("UPDATE products SET stock_quantity = ? WHERE id = ?", 
                             (new_quantity, product_options[selected_product]))
                st.success("Lagerbestand aktualisiert!")
                st.rerun()

# MARKETING
elif page == "üéÅ Marketing":
    st.markdown("""
        <div style='text-align: center; padding: 1rem 0; margin-bottom: 2rem;'>
            <h1 style='font-size: 2.5rem; font-weight: 600; color: #2c3e50;'>üéÅ Marketing & Gutscheine</h1>
        </div>
    """, unsafe_allow_html=True)
    
    tab1, tab2 = st.tabs(["Gutscheine", "Treueprogramm"])
    
    with tab1:
        st.subheader("Gutschein erstellen")
        customers = get_customers()
        customer_options = {f"{c['first_name']} {c['last_name']}": c['id'] for c in customers} if customers else {}
        customer_options["Allgemein"] = None
        
        selected_customer = st.selectbox("Kunde (optional)", ["Allgemein"] + list(customer_options.keys()) if customer_options else ["Allgemein"])
        amount = st.number_input("Gutscheinwert (‚Ç¨)", min_value=1.0, step=1.0, value=25.0)
        valid_until = st.date_input("G√ºltig bis", value=datetime.now() + timedelta(days=365))
        
        if st.button("Gutschein erstellen"):
            import random
            import string
            code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            customer_id = customer_options.get(selected_customer) if selected_customer != "Allgemein" else None
            
            execute_update("""
                INSERT INTO vouchers (code, customer_id, amount, valid_until)
                VALUES (?, ?, ?, ?)
            """, (code, customer_id, amount, str(valid_until)))
            st.success(f"‚úÖ Gutschein erstellt! Code: **{code}**")
    
    with tab2:
        st.subheader("Treueprogramm √úbersicht")
        customers = get_customers()
        if customers:
            df_loyalty = pd.DataFrame(customers)
            df_loyalty = df_loyalty.sort_values('loyalty_points', ascending=False)
            
            st.dataframe(df_loyalty[['first_name', 'last_name', 'loyalty_points']], 
                        use_container_width=True, hide_index=True)
            
            # Treuepunkte manuell vergeben
            st.subheader("Treuepunkte vergeben")
            customer_options = {f"{c['first_name']} {c['last_name']}": c['id'] for c in customers}
            selected_customer = st.selectbox("Kunde", list(customer_options.keys()))
            points = st.number_input("Punkte", min_value=-1000, max_value=1000, value=0)
            
            if st.button("Punkte vergeben"):
                execute_update("""
                    UPDATE customers 
                    SET loyalty_points = loyalty_points + ?
                    WHERE id = ?
                """, (points, customer_options[selected_customer]))
                st.success("Treuepunkte aktualisiert!")
                st.rerun()

# ANALYTICS
elif page == "üìà Analytics":
    st.markdown("""
        <div style='text-align: center; padding: 1rem 0; margin-bottom: 2rem;'>
            <h1 style='font-size: 2.5rem; font-weight: 600; color: #2c3e50;'>üìà Analytics & Reports</h1>
        </div>
    """, unsafe_allow_html=True)
    
    tab1, tab2, tab3 = st.tabs(["Umsatz", "Dienstleistungen", "Kunden"])
    
    with tab1:
        st.subheader("Umsatzanalyse")
        date_range = st.selectbox("Zeitraum", ["Letzte 7 Tage", "Letzte 30 Tage", "Letzte 90 Tage", "Dieses Jahr"])
        
        days = {"Letzte 7 Tage": 7, "Letzte 30 Tage": 30, "Letzte 90 Tage": 90, "Dieses Jahr": 365}
        days_back = days[date_range]
        
        sales_data = execute_query("""
            SELECT sale_date, SUM(total_amount - discount) as total, COUNT(*) as count
            FROM sales
            WHERE sale_date >= date('now', '-' || ? || ' days')
            GROUP BY sale_date
            ORDER BY sale_date
        """, (days_back,))
        
        if sales_data:
            df = pd.DataFrame(sales_data)
            total_revenue = df['total'].sum()
            avg_revenue = df['total'].mean()
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Gesamtumsatz", f"‚Ç¨{total_revenue:.2f}")
            with col2:
                st.metric("Durchschnitt pro Tag", f"‚Ç¨{avg_revenue:.2f}")
            with col3:
                st.metric("Anzahl Verk√§ufe", int(df['count'].sum()))
            
            fig = px.line(df, x='sale_date', y='total', 
                         labels={'sale_date': 'Datum', 'total': 'Umsatz (‚Ç¨)'},
                         title="Umsatzentwicklung")
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Noch keine Verkaufsdaten vorhanden")
    
    with tab2:
        st.subheader("Dienstleistungsanalyse")
        service_stats = execute_query("""
            SELECT s.name, s.category, COUNT(si.id) as count, SUM(si.price) as revenue
            FROM sale_items si
            JOIN services s ON si.item_id = s.id
            WHERE si.item_type = 'service'
            AND si.sale_id IN (SELECT id FROM sales WHERE sale_date >= date('now', '-30 days'))
            GROUP BY s.id, s.name, s.category
            ORDER BY count DESC
        """)
        
        if service_stats:
            df = pd.DataFrame(service_stats)
            fig = px.bar(df, x='name', y='count', color='category',
                        labels={'name': 'Dienstleistung', 'count': 'Anzahl'},
                        title="Beliebteste Dienstleistungen")
            st.plotly_chart(fig, use_container_width=True)
            
            st.dataframe(df, use_container_width=True, hide_index=True)
        else:
            st.info("Noch keine Daten vorhanden")
    
    with tab3:
        st.subheader("Kundenanalyse")
        customer_stats = execute_query("""
            SELECT c.first_name || ' ' || c.last_name as name, 
                   COUNT(s.id) as visits,
                   SUM(s.total_amount - s.discount) as total_spent,
                   c.loyalty_points
            FROM customers c
            LEFT JOIN sales s ON c.id = s.customer_id
            GROUP BY c.id, c.first_name, c.last_name, c.loyalty_points
            HAVING visits > 0
            ORDER BY total_spent DESC
            LIMIT 20
        """)
        
        if customer_stats:
            df = pd.DataFrame(customer_stats)
            st.dataframe(df, use_container_width=True, hide_index=True)
        else:
            st.info("Noch keine Kundendaten vorhanden")

# AI ASSISTANT
elif page == "ü§ñ AI Assistant":
    # ChatGPT-√§hnliches Design CSS
    st.markdown("""
        <style>
        /* ChatGPT-√§hnliches Design */
        .chatgpt-container {
            max-width: 768px;
            margin: 0 auto;
            padding: 0;
            height: calc(100vh - 200px);
            display: flex;
            flex-direction: column;
        }
        
        .chatgpt-header {
            text-align: center;
            padding: 1.5rem 0;
            border-bottom: 1px solid #e5e5e5;
            margin-bottom: 0;
            background: #ffffff;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .chatgpt-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }
        
        .chatgpt-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem 0;
            background: #ffffff;
            scroll-behavior: smooth;
        }
        
        .chatgpt-message {
            display: flex;
            gap: 1rem;
            padding: 1.5rem 1rem;
            margin-bottom: 0;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chatgpt-message.user {
            background: #ffffff;
        }
        
        .chatgpt-message.assistant {
            background: #f7f7f8;
        }
        
        .chatgpt-avatar {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        
        .chatgpt-avatar.user {
            background: #19c37d;
            color: white;
        }
        
        .chatgpt-avatar.assistant {
            background: #ab68ff;
            color: white;
        }
        
        .chatgpt-content {
            flex: 1;
            padding-top: 0.25rem;
            line-height: 1.75;
            color: #374151;
            font-size: 0.95rem;
        }
        
        .chatgpt-input-container {
            position: sticky;
            bottom: 0;
            background: #ffffff;
            padding: 1rem 0;
            border-top: 1px solid #e5e5e5;
            margin-top: auto;
        }
        
        .chatgpt-examples {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            padding: 1rem 0;
            max-width: 768px;
            margin: 0 auto;
        }
        
        .chatgpt-example-btn {
            padding: 0.75rem 1rem;
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            font-size: 0.875rem;
            color: #374151;
            transition: all 0.2s;
        }
        
        .chatgpt-example-btn:hover {
            background: #f7f7f8;
            border-color: #d1d5db;
        }
        
        .chatgpt-empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #6b7280;
        }
        
        .chatgpt-empty-state h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }
        
        .chatgpt-settings {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 101;
        }
        
        /* Streamlit Chat Input Anpassung */
        .stChatInput {
            max-width: 768px;
            margin: 0 auto;
        }
        
        .stChatInput > div {
            border-radius: 24px;
            border: 1px solid #d1d5db;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        .stChatInput > div:focus-within {
            border-color: #10a37f;
            box-shadow: 0 0 0 3px rgba(16, 163, 127, 0.1);
        }
        
        /* Scrollbar Styling */
        .chatgpt-messages::-webkit-scrollbar {
            width: 8px;
        }
        
        .chatgpt-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .chatgpt-messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        
        .chatgpt-messages::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
        
        /* Hide Streamlit default chat styling */
        [data-testid="stChatMessage"] {
            background: transparent !important;
            padding: 0 !important;
        }
        
        [data-testid="stChatMessage"] > div {
            background: transparent !important;
        }
        </style>
    """, unsafe_allow_html=True)
    
    from ai_assistant import (
        check_ollama_available, 
        get_available_models, 
        download_model, 
        chat_with_llm,
        get_crm_context
    )
    
    # Ollama Status pr√ºfen
    ollama_available = check_ollama_available()
    
    # Einstellungen in Sidebar
    with st.sidebar:
        st.markdown("### ‚öôÔ∏è Einstellungen")
        
        if not ollama_available:
            st.error("‚ö†Ô∏è Ollama nicht verf√ºgbar")
            st.info("""
            **Ollama installieren:**
            
            1. Download: https://ollama.ai/download
            2. Terminal: `ollama serve`
            3. Modell: `ollama pull llama3.2`
            """)
            if st.button("üîÑ Status pr√ºfen"):
                st.rerun()
            selected_model = "llama3.2"
        else:
            st.success("‚úÖ Ollama verf√ºgbar")
            models = get_available_models()
            
            if models:
                selected_model = st.selectbox("Modell", models, index=0 if "llama3.2" in models else 0)
            else:
                st.warning("Keine Modelle gefunden")
                model_to_download = st.text_input("Modellname", value="llama3.2")
                if st.button("üì• Herunterladen"):
                    with st.spinner("Lade Modell..."):
                        if download_model(model_to_download):
                            st.success("‚úÖ Erfolgreich!")
                            st.rerun()
                        else:
                            st.error("‚ùå Fehler")
                selected_model = "llama3.2"
        
        st.markdown("---")
        if st.button("üóëÔ∏è Chat l√∂schen"):
            if 'chat_history' in st.session_state:
                st.session_state.chat_history = []
            st.rerun()
    
    # ChatGPT-√§hnliches Chat-Interface
    st.markdown("""
        <div class="chatgpt-container">
            <div class="chatgpt-header">
                <h1>üíá‚Äç‚ôÄÔ∏è AI Sales Assistant</h1>
            </div>
            <div class="chatgpt-messages" id="chatMessages">
    """, unsafe_allow_html=True)
    
    # Chat-Verlauf initialisieren
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    
    # System-Prompt f√ºr den AI Assistant
    system_context = """Du bist ein hilfreicher AI-Assistant f√ºr ein Friseur- und Beauty-Salon CRM-System. 
Du hilfst bei Fragen zu:
- Kundenverwaltung
- Terminbuchung
- Verkaufsempfehlungen
- Produktempfehlungen
- Marketing-Strategien
- Salon-Management

Antworte immer freundlich, professionell und auf Deutsch."""
    
    # CRM-Kontext hinzuf√ºgen
    crm_context = get_crm_context()
    if crm_context:
        system_context += f"\n\nAktuelle CRM-Daten:\n{crm_context}"
    
    # Chat-Verlauf anzeigen (ChatGPT-Style)
    if not st.session_state.chat_history:
        # Leerer Zustand mit Beispiel-Fragen
        st.markdown("""
            <div class="chatgpt-empty-state">
                <h2>Wie kann ich Ihnen helfen?</h2>
                <p>Stellen Sie Fragen zu Ihrem Salon-CRM oder w√§hlen Sie eine Beispiel-Frage:</p>
            </div>
        """, unsafe_allow_html=True)
        
        example_questions = [
            "Wie viele Kunden haben wir?",
            "Welche Produkte haben niedrigen Bestand?",
            "Wie kann ich mehr Umsatz generieren?",
            "Welche Dienstleistungen sind am beliebtesten?",
            "Wie kann ich Kunden besser binden?",
            "Was sind gute Marketing-Strategien f√ºr Salons?"
        ]
        
        st.markdown('<div class="chatgpt-examples">', unsafe_allow_html=True)
        cols = st.columns(2)
        for i, question in enumerate(example_questions):
            with cols[i % 2]:
                if st.button(f"üí¨ {question}", key=f"example_{i}", use_container_width=True):
                    st.session_state.chat_history.append({'role': 'user', 'content': question})
                    with st.spinner("ü§ñ Denke nach..."):
                        full_prompt = f"{system_context}\n\nBenutzer: {question}\n\nAssistant:"
                        response = chat_with_llm(full_prompt, model=selected_model)
                        st.session_state.chat_history.append({'role': 'assistant', 'content': response})
                    st.rerun()
        st.markdown('</div>', unsafe_allow_html=True)
    else:
        # Nachrichten im ChatGPT-Stil anzeigen
        for message in st.session_state.chat_history:
            if message['role'] == 'user':
                st.markdown(f"""
                    <div class="chatgpt-message user">
                        <div class="chatgpt-avatar user">üë§</div>
                        <div class="chatgpt-content">{message['content']}</div>
                    </div>
                """, unsafe_allow_html=True)
            else:
                st.markdown(f"""
                    <div class="chatgpt-message assistant">
                        <div class="chatgpt-avatar assistant">ü§ñ</div>
                        <div class="chatgpt-content">{message['content']}</div>
                    </div>
                """, unsafe_allow_html=True)
    
    st.markdown("</div></div>", unsafe_allow_html=True)
    
    # Eingabefeld (ChatGPT-Style)
    user_input = st.chat_input("Nachricht an AI Assistant...")
    
    if user_input:
        # Benutzernachricht hinzuf√ºgen
        st.session_state.chat_history.append({'role': 'user', 'content': user_input})
        
        # AI-Antwort generieren
        with st.spinner("ü§ñ Denke nach..."):
            full_prompt = f"{system_context}\n\nBenutzer: {user_input}\n\nAssistant:"
            response = chat_with_llm(full_prompt, model=selected_model)
            st.session_state.chat_history.append({'role': 'assistant', 'content': response})
        
        st.rerun()
    
    # JavaScript f√ºr Auto-Scroll
    st.markdown("""
        <script>
        // Auto-Scroll zum Ende der Nachrichten
        setTimeout(function() {
            const messagesDiv = document.getElementById('chatMessages');
            if (messagesDiv) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        }, 100);
        </script>
    """, unsafe_allow_html=True)

